% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pipe.R
\name{pipe_operator}
\alias{pipe_operator}
\alias{\%>.\%}
\alias{\%>_\%}
\alias{debug_flow}
\title{Flow pipeline operators and debugging function}
\usage{
x \%>.\% expr

x \%>_\% expr

debug_flow()
}
\arguments{
\item{x}{Value or \strong{Flow} object to pass to the pipeline.}

\item{expr}{Expression to evaluation in the pipeline.}
}
\description{
Pipe operators. \code{\link{\%>.\%}} is a very simple and efficient pipe
operator. \code{\link{\%>_\%}} is more complex. It forces conversion to
a \strong{Flow} object inside a pipeline and automatically manage non-standard
evaluation through creation and unquoting of \strong{quosure}s for named arguments
whose name ends with \verb{_}.
}
\details{
With \code{\%>.\%}, the value must be explicitly indicated with a
\code{.} inside the expression. The expression is \strong{not} modified, but the value
is first assigned into the calling environment as \code{.} (warning! possibly
replacing any existing value... do \strong{not} use \code{.} to name other objects).
Also the expression is saved as \code{.call} in the calling environment so that
\code{debug_flow()} can retrieve are rerun it easily. If a \strong{Flow} object is used
with \code{\%>.\%}, the \code{.value} is extracted from it into \code{.} first (and
thus the \strong{Flow} object is lost).

In the case of \code{\%>_\%} the \strong{Flow} object is passed or created, it is
also assigned in the calling environment as \code{..}. This can be used to refer
to \strong{Flow} object content within the pipeline expressions (e.g., \code{..$var}).

For \code{\%>_\%}, the expression is reworked in such a way that a suitable
lazyeval syntax is constructed for each variable whose name ends with \verb{_},
and that variable is explicitly searched starting from \code{..}. Thus, \code{x_} is
replaced by \code{!!..$x}. For such variables appearing at left of an \code{=} sign, it
is also replaced by \verb{:=} to keep correct \R syntax (\verb{var_ =} =>
\verb{!!..$var :=}). This way, you just need to follow special variables by \verb{_},
both in the \code{flow()} function arguments (to create quosures), and to the
NSE expressions used inside the pipeline to get the job done! The raw
expression is saved as \code{.call_raw}, while the reworked call is saved as
\code{.call} for possible further inspection and debugging.

Finally, for \code{\%>_\%}, if \code{expr} is \code{.}, then, the last value from the
pipe is extracted from the \strong{Flow} object and returned. It is equivalent,
thus, to \code{flow_obj$.value}.

You can mix \code{\%>.\%} and \code{\%>_\%} within the same pipeline. In case
you use \code{\%>.\%} with a flow pipeline, it "unflows" it, extracting
\code{.value} from the \strong{Flow} object and further feeding it to the pipeline.
}
\examples{
# A simple pipeline with \%>.\% (explicit position of '.' required)
library(svFlow)
library(dplyr)
data(iris)
iris2 <- iris \%>.\%
  mutate(., log_SL = log(Sepal.Length)) \%>.\%
  filter(., Species == "setosa")

# The \%>.\% operator is much faster than magrittr's \%>\%
# (although this has no noticeable impact in most situations when the
# pipeline in used in an ad hoc way, outside of loops or other constructs
# that call it a larger number of times)
}
\seealso{
\link{flow}, \link{quos_underscore}
}
\concept{pipeline operators and debugging}
\keyword{utilities}
