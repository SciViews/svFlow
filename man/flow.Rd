% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flow.R
\name{flow}
\alias{flow}
\alias{enflow}
\alias{is_flow}
\alias{is.flow}
\alias{$.Flow}
\alias{$<-.Flow}
\alias{print.Flow}
\title{Create Flow objects to better organize pipelines in R}
\usage{
flow(. = NULL, .value = NULL, ...)

enflow(.value, env = caller_env(), objects = ls(env))

is_flow(x)

is.flow(x)

\method{$}{Flow}(x, name)

\method{$}{Flow}(x, name) <- value

\method{print}{Flow}(x, ...)
}
\arguments{
\item{.}{If a \strong{Flow} object is provided, heritate from it, otherwise,
create a new \strong{Flow} object heritating from \code{.GlobalEnv} with \code{.} as pipe
value.}

\item{.value}{The pipe value to pass to the object (used instead of \code{.},
in case both are provided).}

\item{...}{For \code{flow()}, named arguments of other objects to create inside
the \strong{Flow} object. If the name ends with \code{_}, then, the expression is
automatically captured inside a \emph{quosure}* (see \code{\link[=quos_underscore]{quos_underscore()}}).
For \code{print()}, further arguments passed to the delegated \code{object_print()}
function (if it exists inside the \strong{Flow} object), or to the \code{print()}
method of the object inside \code{.value}.}

\item{env}{The environment to use for populating the \strong{Flow} object. All
objects from this environment are injected into it, with the objects not
starting with a dot and ending with an underscore (\code{_}) automatically
converted into \code{quosures}. The object provided to \code{.value=} becomes the
default value of the \code{Flow} object, that is, the data transferred to the
pipeline.}

\item{objects}{A character string with the name of the objects from \code{env}
to import into the \strong{Flow} object. If \code{env} is the calling environment (by
default), \code{.value} is the name of an object, and that name appears in
\code{objects} too, it is excluded from it to avoid importing it twice.
from that}

\item{x}{An object (a \strong{Flow} object, or anyting to test if it is a \strong{Flow}
object in \code{is_flow()}).}

\item{name}{The name of the item to get from a \strong{Flow} object. If \code{name}
starts with two dots (\code{..}), the item is searched in the \strong{Flow} object
itself without inheritance, but the name is stripped of its leading two dots
first! If the content is a \strong{quosure}, it is automatically unquoted, and for
the assignation version, if name ends with \code{_}, the expression is
automatically converted into a \strong{quosure}.}

\item{value}{The value or expression to assign to \code{name} inside the \strong{Flow}
object.}
}
\description{
\strong{Flow} objects, as explicitly created by \code{flow()}, or implicitly by the
\code{\link{\%>_\%}} pipe operator are \strong{proto} objects (class-less objects
with possible inheritance) that can be combined nicely with pipelines using
the specialized flow pipe operator \code{\link{\%>_\%}} (or by using \code{$}).
They allow for encapsulating satellite objects/variables related to the
pipeline, and they deal with non-standard evaluations using the tidyeval
mechanism automatically with minimal changes required by the user.
}
\details{
\code{enflow()} creates a \strong{Flow} object in the head of a "flow pipeline" in the
context of a functional sequence, that is a function that converts an
\emph{ad hoc}, single use pipeline into a function reuseable in a different
context. Satellite data become arguments of the function.

When a \strong{Flow} object is created from scratch, it always inherits
from \code{.GlobalEnv}, no mather where the expression was executed (in fact, it
inherits from an empty root \strong{Flow} object itself inheriting from
\code{.GlobalEnv}). This is a deliberate design choice to overcome some
difficulties and limitations of \strong{proto} objects, see \code{\link[=proto]{proto()}}.
\code{enflow()} creates a \strong{Flow} object and populates it automatically with all
the objects that are present in \code{env=} (by default, the calling environment).
It is primarily intended to be used inside a function, as first instruction
of a "flow pipeline". Hence, it collects all function arguments inside that
pipeline in a most convenient way.
}
\examples{
library(flow)
library(dplyr)
data(iris)

foo <- function(data, x_ = Sepal.Length, y_ = log_SL,
fun_ = mean, na_rm = TRUE)
  enflow(data) \%>_\%
  mutate(., y_ = log(x_)) \%>_\%
  summarise(., fun_ = fun_(y_,
    na.rm = na_rm_)) \%>_\% .

foo(iris)

foo(iris, x_ = Petal.Width)

foo(iris, x_ = Petal.Width, fun_ = median)
# Unfortunately, this does not work, due to limitations of tidyeval's :=
#foo(iris, x_ = Petal.Width, fun_ = stats::median)

foo2 <- function(., x_ = Sepal.Length, y_ = log_SL, na_rm = TRUE)
  enflow(.)

foo2
foo2(1:10) -> foo_obj
ls(foo_obj)
}
\seealso{
\link{str.Flow}, \link{quos_underscore}, \code{\link{\%>_\%}}
}
\concept{
class-less objects for better R pipelines
}
\keyword{utilities}
